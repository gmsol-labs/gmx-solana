//! # The GMSOL Store Program
//!
//! The GMSOL Store Program is a Solana Program developed using [Anchor](anchor_lang).
//! It defines the data structure of the main Accounts for the GMSOL
//! and provides a role-based permission management framwork based on the [`Store`](states::Store) Account.
//!
//! It mainly consists of the following components:
//! - Core data strcutures defined in the [`states`] module.
//! - Instructions are defined in [this module](gmsol_store), which is generated by the [#\[program\]](macro@program) macro.
//! - Events generated during the execution of instructions defined in [`events`] module.
//! - Constants such as default market parameters found in the [`constants`] module.
//! - Various helper functions and implementations defined in the [`utils`] module.
//!   Notably, if external Programs wish to use the permission management feature provided by the Store Program,
//!   the relevant trait definitions (like [`Authentication`](utils::Authentication)) can be found in the [`utils`] module.
//!
//! ## Overall Design
//! GMSOL primarily consists of the *Store Program*, *Exchange Program*, and off-chain *Keepers*.
//! The *Store Program* (which is defined in this crate) provides management instrcutions for core
//! data accounts and features a role-based permission system to management access to these data accounts.
//! We strive to keep the instructions in the Store Program as simple and straightforward as possible.
//! For example, although the creation of a [`Market`](states::Market) account, the creation
//! of the correspoding market token, and the creation of market vaults to be used typically need to
//! be used together to be meaningful, they are defined separately in the Store Program, with
//! independent precondition and permission validations. The actual market creation instruction,
//! which includes the invocation of the aforementioned instructions, is defined in the
//! Exchange Program. This design allows us to update the logic of specific operations by updating
//! the Exchange Program without needing to modify the Store Program.
//!
//! However, for the execution instructions of actions (such as the execution of orders), which often
//! require significant computational resources, we need to optimize their implementation carefully.
//! Particularly, we need to avoid the additional overhead caused by CPI (Cross-Program Invocation).
//! Therefore, their core parts are implemented directly in the Store Program.
//!
//! Next we will introduce the data accounts defined in the Store Program and the instrucionts for
//! operating them one by one.
//!
//! ## Store Account
//! A [`Store`](states::Store) Account serves as both an authority and a global configuration
//! storage.
//!
//! #### Store Account as an Authority
//! The address of a Store Account is a PDA (Program Derived Address), which can be used to sign
//! instructions during CPI calls (see [cpi-with-pda-signer] for details). This allows the Store
//! Account to be used as an authority for extenral resources. For example, the Store Account is
//! the owner of Market Vaults (SPL Token Accounts) and the mint authority of Market Tokens
//! (SPL Mint Accounts). When executing transfers in and out of the Market Vault, the Store Account
//! is used as the Signer for the corresponding CPI to authorize the opeartion.
//!
//! Besides serving as an authority for external resources, the Store Account is also the authority
//! for internal resources within GMSOL. Most Data Accounts in the Store Program have a `store` field
//! indicating *they are managed by this Store Account*. Additionally, the Store Account maintains a
//! permissions table that records all addresses with permissions in this store and the permissions
//! they hold.
//!
//! Only addresses with the required permissions in this store are allowed to modify the Data Accounts
//! under its management.
//!
//! More specifically, most instructions in the Store Program require a Signer and a Store Account in
//! addition to the Data Account being operated on. Before executing the operation, the instruction
//! verifies:
//! 1. The Data Account is managed by the Store (by checking if the `store` field of the Data Account
//!    matches the address of the Store Account).
//! 2. The Signer has the required permissions in the given Store.
//!
//! For example, there is an instruction ([`push_to_token_map`]) in the Store Program to add a new token
//! config to a token map. This instruction requires an `authority` (a signer, which can be considered
//! the initiator of the instruction), a store account, and the token map to which the new token config
//! will be added. The instruction verifies that the `store` field of the token map matches the provided
//! store account and checks the permissions of the `authority` has the
//! [`MARKET_KEEPER`](states::RoleKey::MARKET_KEEPER) permission in this store.
//!
//! Currently, the Store Program allows the creation of a Store Account permissionlessly. In the GMSOL
//! system, we refer to a Store Account and the accounts it manages as a *deployment* of GMSOL. A Store
//! Account corresponds to one deployment, and different deployments are independent of each other,
//! with completely isolated permission settings.
//!
//! #### Store Account as Global Configuration Storage
//! Since the Store Account is involved in almost all Store Program instructions, it is very suitable for
//! storing global configrations. Currently, we store the following configurations in the Store Account:
//! 1. The authority (admin) of the store and the permissions table for other addresses.
//! 2. The address of the token map used in this deployment.
//! 3. Treasury configuration.
//! 4. Verification configuration for oracles.
//! 5. Other global configurations.
//!
//! #### Store Account Address Derivation Rules
//! The address of the Store Account is a PDA. Sepecifically, the Store Account address is derived using
//! the following [seeds]:
//! 1. A constant [`Store::SEED`](states::Store).
//! 2. A sha256 hashed key string.
//!
//! This means that we can generate a Store Account address from any key string (with a length not
//! exceeding [`MAX_LEN`](states::Store::MAX_LEN)). However, this is not unique, as multiple key strings
//! may generate the same Store Account address. The store derived from an empty key string is referred to
//! as the default store, which si typically controlled by the GMSOL Program deployer.
//!
//! Given the possibility of multiple key strings deriving the same Store Account address, to ensure that
//! a store corresponds to a signle key string, the key string used during store creation is saved in the
//! account in its original form. Thus, regardless of how many key strings correspond to the same store,
//! only the key string specified by the store creator is saved in the store. This ensures that each
//! successfully created store has a unique key.
//!
//! [cpi-with-pda-signer]: https://solana.com/docs/core/cpi#cpi-with-pda-signer
//! [seeds]: https://solana.com/docs/core/pda#how-to-derive-a-pda
//!
//! ### Instructions for Store Accounts
//! - [`initialize`](gmsol_store::initialize): Create a new [`Store`](states::Store) account.
//! - [`transfer_store_authority`]: Transfer the authority of the given store to a new authority.
//!
//! ## Role-based Permission Management
//!
//! The complete role-based permission table for each GMSOL deployment is directly stored in the
//! [`Store`](states::Store) Account of that deployment. The current permission structure in GMSOL includes:
//! - (Unique) Administrator: The administrator's address is directly stored in the `authority` field
//!   of the [`Store`](states::Store) Account. Only this address can modify the permission table.
//! - Custom Roles: The custom role table and member table are stored in the `role` field of the
//!   [`Store`](states::Store) account as a [`RoleStore`](states::RoleStore) structure.
//!
//! All instructions in GMSOL are either permissionless or require the caller to have an admin role
//! or a role defined in [`RoleStore`](states::RoleStore). For instructions that require permissions,
//! the checks are performed using the `access_control` macro provied by [`anchor`](anchor_lang).
//! The following example illustrates the permission structure in GMSOL:
//!
//! User `GMsoQfjzWE8ogYJPew3zX8fCTF8vedbgFV4qjUCZGTtm` calls the `initialize` instruction of
//! the Store Program, creating a Store Account (this instruction is permissionless). The authority
//! of the Store is automatically set to GMsoQfjzWE8ogYJPew3zX8fCTF8vedbgFV4qjUCZGTtm.
//! At this point, the permission structure of the Store is as follows:
//!
//! - Admin: `GMsoQfjzWE8ogYJPew3zX8fCTF8vedbgFV4qjUCZGTtm`
//! - Role Table: Empty
//! - Member Table: Empty
//!
//! Subsequently, the user calls the enable_role instruction to create the roles ROLE_A and MARKET_KEEPER.
//! The permission structure of the Store then becomes:
//!
//! - Admin: `GMsoQfjzWE8ogYJPew3zX8fCTF8vedbgFV4qjUCZGTtm`
//! - Role Table: `ROLE_A`, `MARKET_KEEPER`
//! - Member Table: Empty
//!
//! Next, the user uses the grant_role instruction to grant the `ROLE_A` role to
//! `FoMW5qtiTMcR3Y5zFF7ZmsG3maGac8rPaveHvKiWWpaJ` and the `MARKET_KEEPER` role to
//! `KeCJTnq7u6xE1nwiou2RD4yj6hNTZnb8xYcavqSSgRe`. The permission structure of the Store then becomes:
//!
//! - Admin: `GMsoQfjzWE8ogYJPew3zX8fCTF8vedbgFV4qjUCZGTtm`
//! - Role Table: `ROLE_A`, `MARKET_KEEPER`
//! - Member Table: `FoMW5qtiTMcR3Y5zFF7ZmsG3maGac8rPaveHvKiWWpaJ` with `ROLE_A`;
//!   `KeCJTnq7u6xE1nwiou2RD4yj6hNTZnb8xYcavqSSgRe` with `MARKET_KEEPER`
//!
//! Since GMSOL's permission table supports granting multiple roles to the same address, the user can also
//! grant the `ROLE_A` role to `KeCJTnq7u6xE1nwiou2RD4yj6hNTZnb8xYcavqSSgRe`. The permission structure of
//! the Store then becomes:
//!
//! - Admin: `GMsoQfjzWE8ogYJPew3zX8fCTF8vedbgFV4qjUCZGTtm`
//! - Role Table: `ROLE_A`, `MARKET_KEEPER`
//! - Member Table: `FoMW5qtiTMcR3Y5zFF7ZmsG3maGac8rPaveHvKiWWpaJ` with `ROLE_A`;
//!   `KeCJTnq7u6xE1nwiou2RD4yj6hNTZnb8xYcavqSSgRe` with `MARKET_KEEPER` and `ROLE_A`
//!
//! Since `KeCJTnq7u6xE1nwiou2RD4yj6hNTZnb8xYcavqSSgRe` has the `MARKET_KEEPER` role, this address can
//! sign instructions related to market management, such as `toggle_market`. However, this address cannot
//! sign the `market_transfer_out` instruction, which requires the `CONTROLLER` role.
//!
//! Meanwhile, `FoMW5qtiTMcR3Y5zFF7ZmsG3maGac8rPaveHvKiWWpaJ` cannot sign any built-in instructions of
//! the Store Program that require permissions, as it only has the `ROLE_A` role, which is not sufficient
//! for any permission-required built-in instructions. Although custom roles like `ROLE_A` are not directly
//! supported by the Store Program, other programs can use the Store Program's `check_role` instruction to
//! verify if an address has the `ROLE_A` role, thereby providing support for that role.
//!
//! The roles supported by the Store Program are defined in [`RoleKey`](states::RoleKey) and include all
//! roles needed for built-in instructions. However, no roles are added by default when the Store is initialized,
//! so the Store's administrator must manually enable them using `enable_role`.
//!
//! #### Authentication
//! This crate also provide helper trait [`Authenticate`](utils::Authenticate) to simpify the permission validations,
//! which provides methods that can be used together with [#\[access_control\]](macro@access_control) macro for
//! [`Accounts`] types that implement [`Authentication`](utils::Authentication).
//!
//! ### Instructions for Permission Management
//! - [`enable_role`]: Insert or enable a role for the given store.
//! - [`disable_role`]: Disable an existing role for the given store.
//! - [`grant_role`]: Grant a role to the given user in the given store.
//! - [`revoke_role`]: Revoke a role from the given user in the given store.
//! - [`check_admin`](gmsol_store::check_admin): Check that the signer is the admin of the given store,
//!   throw error if the check fails.
//! - [`check_role`](gmsol_store::check_role): Check that the signer has the given role in the given store,
//!   throw error if the check fails.
//! - [`has_admin`](gmsol_store::has_admin): Return whether the given address is the admin of the given store,
//!   or not.
//! - [`has_role`](gmsol_store::has_role): Return whether the given address has the given role in the given store,
//!   or not.
//!
//! ## Oracle Price Management
//! In GMSOL, market-related actions such as deposit and order require the latest prices from the oracle to be executed.
//! The process of providing oracle prices is primarily defined and implemented in the Exchange Program.
//! However, for the sake of completeness, we will briefly outline the process here:
//!
//! 1. When executing an action creation instruction, the Exchange Program analyzes the required token prices and writes
//!    the list of tokens needing prices, along with relevant information, into the action's account for Order Keepers to use.
//!
//! 2. Order Keepers prepare Feed Accounts that store the required price information for these tokens based on the
//!    requirements in the action account. These accounts are generally owned by the selected Price Oracle Program,
//!    ensuring their correctness. These Feed Accounts are then added to the accounts list of the action execution instruction.
//!
//! 3. When executing the action execution instruction, the Exchange Program parses and verifies the price information
//!    provided in the Feed Accounts using instructions provided by the Store Program. This verified information is then
//!    written into the [`Oracle`](states::Oracle) Account of the Store Program for subsequent operations.
//!    The Oracle Account must be empty before the action execution and needs to be cleared after the action is completed.
//!
//! The token price-related information mentioned in step one (such as the expected price provider and feed ID) is stored
//! in the [`TokenMap`](states::TokenMap) account of the Store Program. The [`TokenMap`](states::TokenMap),
//! the [`Oracle`](states::Oracle) account mentioned in step three, and their related instructions are the main contents
//! introduced in this section.
//!
//! ### Instructions for [`TokenConfig`](states::TokenConfig) and token maps.
//! - [`initialize_token_map`](gmsol_store::initialize_token_map): Initialize a new token map account.
//!   This is a permissionless instruction.
//! - [`set_token_map`]: Set the token map address used in the given store.
//! - [`push_to_token_map`]: Push a new token config for an existing token to the given token map.
//! - [`push_to_token_map_synthetic`]: Push a new token config for a "synthetic"
//!   token to the given token map.
//! - [`toggle_token_config`]: Enable or disable a token config of the given token map.
//! - [`set_expected_provider`]: Set the expected provider for the given token.
//! - [`set_feed_config`]: Set the feed config of the given provider for the given token.
//! - [`is_token_config_enabled`](gmsol_store::is_token_config_enabled): Check if the config for the given token is enabled.
//! - [`token_expected_provider`](gmsol_store::token_expected_provider): Get the expected provider set for the given token.
//! - [`token_feed`](gmsol_store::token_feed): Get the feed address of the given provider set for the given token.
//! - [`token_timestamp_adjustment`](gmsol_store::token_timestamp_adjustment): Get the timestamp adjustment of the given
//!   provider for the give token.
//! - [`token_name`](gmsol_store::token_name): Get the name of the given token.
//! - [`token_decimals`](gmsol_store::token_decimals): Get the token decimals of the given token.
//! - [`token_precision`](gmsol_store::token_precision): Get the price precision of the given token.
//!
//! ### Instructions for [`Oracle`](states::Oracle) accounts
//! - [`initialize_oracle`]: Initialize a new [`Oracle`](states::Oracle) account.
//! - [`clear_all_prices`](gmsol_store::clear_all_prices): Clear the prices of the given oracle account.
//! - [`set_price`](gmsol_store::set_price): Set a price for the given token in the given oracle account.
//! - [`set_prices_from_price_feed`](gmsol_store::set_prices_from_price_feed): Validate and set prices parsed from the
//!   provided price feed accounts.
//!
//! ## Market Management
//! The instructions related to market management are as follows:
//!
//! ### Instructions for [`Market`](states::Market) management
//! - [`initialize_market`]: Initialize a [`Market`](states::Market) account.
//! - [`remove_market`]: Close the given [`Market`](states::Market) account.
//! - [`toggle_market`]: Enable or diable the given market.
//! - [`market_transfer_in`]: Transfer tokens into the market and record in its balance.
//! - [`market_transfer_out`]: Transfer tokens out from the market and record in its balance.
//! - [`update_market_config`]: Update an item in the market config.
//! - [`update_market_config_with_buffer`]: Update the market config with the given
//!   [`MarketConfigBuffer`](states::MarketConfigBuffer) account.
//! - [`get_validated_market_meta`](gmsol_store::get_validated_market_meta): Validate the market and
//!   return its [meta](states::MarketMeta).
//! - [`get_market_config`](gmsol_store::get_market_config): Read an item from the market config by the key.
//! - [`get_market_meta`](gmsol_store::get_market_meta): Get the [meta](states::MarketMeta) of the market
//!   without validation.
//!
//! ### Instructions for [`MarketConfigBuffer`](states::MarketConfigBuffer) accounts
//! - [`initialize_market_config_buffer`](gmsol_store::initialize_market_config_buffer): Initialize a market config buffer account.
//! - [`set_market_config_buffer_authority`](gmsol_store::set_market_config_buffer_authority): Replace the authority of the market
//!   config buffer account with the new one.
//! - [`close_market_config_buffer`](gmsol_store::close_market_config_buffer): Close the given market config buffer account.
//! - [`push_to_market_config_buffer`](gmsol_store::push_to_market_config_buffer): Push config items to the given market config
//!   buffer account.
//!
//! ### Instructions for market tokens
//! - [`initialize_market_token`]: Initialize a new market token.
//! - [`mint_market_token_to`]: Mint the given amount of market tokens to the destination
//!   account.
//! - [`burn_market_token_from`]: Burn the given amount of market tokens from the given account.
//!
//! ### Instructions for market vaults
//! - [`initialize_market_vault`]: Initialize the market vault for the given token.
//! - [`market_vault_transfer_out`]: Transfer the given amount of tokens out to the destination
//!   account.

/// Instructions.
pub mod instructions;

/// States.
pub mod states;

/// Operations.
pub mod ops;

/// Constants.
pub mod constants;

/// Utils.
pub mod utils;

/// Events.
pub mod events;

pub use self::states::Data;

use self::{
    instructions::*,
    ops::{
        deposit::CreateDepositParams,
        order::{CreateOrderParams, PositionCutKind},
        shift::CreateShiftParams,
        withdrawal::CreateWithdrawalParams,
    },
    states::{
        common::{SwapParams, TokenRecord},
        deposit::TokenParams as DepositTokenParams,
        market::{config::EntryArgs, status::MarketStatus, MarketMeta},
        order::{OrderParams, UpdateOrderParams},
        token_config::TokenConfigBuilder,
        withdrawal::TokenParams as WithdrawalTokenParams,
        PriceProviderKind,
    },
    utils::internal,
};
use anchor_lang::prelude::*;
use gmsol_model::action::Prices;
use gmsol_utils::price::Price;

#[cfg_attr(test, macro_use)]
extern crate static_assertions;

declare_id!("gmX4GEZycT14vqJ3yDoCA5jW53vBaSQpQDYNDXtkWt1");

#[program]
/// Instructions definitions of the GMSOL Store Program.
pub mod gmsol_store {

    use super::*;

    // Data Store.
    /// Create a new [`Store`](states::Store) account.
    ///
    /// # Accounts
    /// *[See the documentation for the accounts.](Initialize).*
    ///
    /// # Arguments
    /// - `key`: The name of the store, also used as seed to derive
    /// the address of the store account. The length of the `key`
    /// cannot exceed [`MAX_LEN`](states::Store::MAX_LEN).
    /// - `authority`: The authority (admin) address that will be set
    /// after the Store is created. If not provided,
    /// [`payer`](Initialize::payer) will be used as the default
    /// authority address.
    ///
    /// # Checks
    /// - The [`payer`](Initialize::payer) is a signer.
    /// - The [`store`](Initialize::store) is not initialized.
    /// - The address of the [`store`](Initialize::store) must be the PDA
    ///   derived from the store account seed [`SEED`](states::Store::SEED)
    ///   and the SHA-256 encoded `key` parameter.
    pub fn initialize(
        ctx: Context<Initialize>,
        key: String,
        authority: Option<Pubkey>,
    ) -> Result<()> {
        instructions::initialize(ctx, key, authority)
    }

    /// Transfer the authority of the given store to a new authority.
    ///
    /// # Accounts
    /// *[See the documentation for the accounts.](TransferStoreAuthority).*
    ///
    /// # Arguments
    /// - `new_authority`: The new authority to be set for the store account.
    ///
    /// # Checks
    /// - The [`authority`](TransferStoreAuthority::authority) must be a signer
    /// and be the `ADMIN` of the store.
    /// - The [`store`](TransferStoreAuthority::store) must have been initialized
    /// and owned by the store program.
    #[access_control(internal::Authenticate::only_admin(&ctx))]
    pub fn transfer_store_authority(
        ctx: Context<TransferStoreAuthority>,
        new_authority: Pubkey,
    ) -> Result<()> {
        instructions::unchecked_transfer_store_authority(ctx, new_authority)
    }

    #[access_control(internal::Authenticate::only_market_keeper(&ctx))]
    pub fn set_token_map(ctx: Context<SetTokenMap>) -> Result<()> {
        instructions::unchecked_set_token_map(ctx)
    }

    pub fn get_token_map(ctx: Context<ReadStore>) -> Result<Option<Pubkey>> {
        instructions::get_token_map(ctx)
    }

    // Roles.
    /// Check that the signer is the admin of the given store, throw error if
    /// the check fails.
    ///
    /// # Accounts
    /// *[See the documentation for the accounts.](CheckRole).*
    ///
    /// # Checks
    /// - The [`authority`](CheckRole::authority) must be a signer and be
    /// the `ADMIN` of the store.
    /// - The [`store`](CheckRole::store) must have been initialized
    /// and owned by the store program.
    pub fn check_admin(ctx: Context<CheckRole>) -> Result<bool> {
        instructions::check_admin(ctx)
    }

    /// Check that the signer has the given role in the given store, throw
    /// error if the check fails.
    ///
    /// # Accounts
    /// *[See the documentation for the accounts.](CheckRole).*
    ///
    /// # Arguments
    /// - `role`: The name of the role to be checked.
    ///
    /// # Checks
    /// - The [`authority`](CheckRole::authority) must be a signer and
    /// must be a member with the `role` role in the store.
    /// - The [`store`](CheckRole::store) must have been initialized
    /// and owned by the store program.
    /// - The `role` must exist and be enabled in the store.
    pub fn check_role(ctx: Context<CheckRole>, role: String) -> Result<bool> {
        instructions::check_role(ctx, role)
    }

    /// Return whether the given address is the admin of the given store, or not.
    ///
    /// # Accounts
    /// *[See the documentation for the accounts.](HasRole).*
    ///
    /// # Arguments
    /// - `authority`: The address to check for admin privileges.
    ///
    /// # Checks
    /// - The [`store`](HasRole::store) must have been initialized
    /// and owned by the store program.
    pub fn has_admin(ctx: Context<HasRole>, authority: Pubkey) -> Result<bool> {
        instructions::has_admin(ctx, authority)
    }

    /// Return whether the given address has the given role in the given store, or not.
    ///
    /// # Accounts
    /// *[See the documentation for the accounts.](HasRole).*
    ///
    /// # Arguments
    /// - `authority`: The address to check for the role.
    /// - `role`: The role to be checked.
    ///
    /// # Checks
    /// - The [`store`](HasRole::store) must have been initialized
    /// and owned by the store program.
    /// - The `role` must exist and be enabled in the store.
    pub fn has_role(ctx: Context<HasRole>, authority: Pubkey, role: String) -> Result<bool> {
        instructions::has_role(ctx, authority, role)
    }

    /// Insert or enable a role for the given store.
    ///
    /// # Accounts
    /// *[See the documentation for the accounts.](EnableRole).*
    ///
    /// # Arguments
    /// - `role`: The name of the role to be added/enabled. The length cannot exceed
    /// [`MAX_ROLE_NAME_LEN`](states::roles::MAX_ROLE_NAME_LEN).
    ///
    /// # Checks
    /// - The [`authority`](EnableRole::authority) must be a signer and be
    /// the `ADMIN` of the store.
    /// - The [`store`](EnableRole::store) must have been initialized
    /// and owned by the store program.
    #[access_control(internal::Authenticate::only_admin(&ctx))]
    pub fn enable_role(ctx: Context<EnableRole>, role: String) -> Result<()> {
        instructions::unchecked_enable_role(ctx, role)
    }

    /// Disable an existing role for the given store.
    /// It has no effect if this role does not exist in the store.
    ///
    /// # Accounts
    /// *[See the documentation for the accounts.](DisableRole).*
    ///
    /// # Arguments
    /// - `role`: The name of the role to be disabled.
    ///
    /// # Checks
    /// - The [`authority`](DisableRole::authority) must be a signer and be
    /// the `ADMIN` of the store.
    /// - The [`store`](DisableRole::store) must have been initialized
    /// and owned by the store program.
    #[access_control(internal::Authenticate::only_admin(&ctx))]
    pub fn disable_role(ctx: Context<DisableRole>, role: String) -> Result<()> {
        instructions::unchecked_disable_role(ctx, role)
    }

    /// Grant a role to the given user in the given store.
    ///
    /// # Accounts
    /// *[See the documentation for the accounts.](GrantRole).*
    ///
    /// # Arguments
    /// - `user`: The user to whom the role is to be granted.
    /// - `role`: The role to be granted to the user.
    ///
    /// # Checks
    /// - The [`authority`](GrantRole::authority) must be a signer and
    /// be the `ADMIN` of the store.
    /// - The [`store`](GrantRole::store) must have been initialized
    /// and owned by the store program.
    /// - The `role` must exist and be enabled in the store.
    #[access_control(internal::Authenticate::only_admin(&ctx))]
    pub fn grant_role(ctx: Context<GrantRole>, user: Pubkey, role: String) -> Result<()> {
        instructions::unchecked_grant_role(ctx, user, role)
    }

    /// Revoke a role from the given user in the given store.
    ///
    /// # Accounts
    /// *[See the documentation for the accounts.](RevokeRole).*
    ///
    /// # Arguments
    /// - `user`: The user to whom the role is to be revoked.
    /// - `role`: The role to be revoked from the user.
    ///
    /// # Checks
    /// - The [`authority`](RevokeRole::authority) must be a signer and be
    /// the `ADMIN` of the store.
    /// - The [`store`](RevokeRole::store) must have been initialized
    /// and owned by the store program.
    /// - The `user` must exist in the member table.
    /// - The `role` must exist and be enabled in the store.
    #[access_control(internal::Authenticate::only_admin(&ctx))]
    pub fn revoke_role(ctx: Context<RevokeRole>, user: Pubkey, role: String) -> Result<()> {
        instructions::unchecked_revoke_role(ctx, user, role)
    }

    // Config.
    #[access_control(internal::Authenticate::only_controller(&ctx))]
    pub fn insert_amount(ctx: Context<InsertAmount>, key: String, amount: u64) -> Result<()> {
        instructions::insert_amount(ctx, &key, amount)
    }

    #[access_control(internal::Authenticate::only_controller(&ctx))]
    pub fn insert_factor(ctx: Context<InsertFactor>, key: String, factor: u128) -> Result<()> {
        instructions::insert_factor(ctx, &key, factor)
    }

    #[access_control(internal::Authenticate::only_controller(&ctx))]
    pub fn insert_address(ctx: Context<InsertAddress>, key: String, address: Pubkey) -> Result<()> {
        instructions::insert_address(ctx, &key, address)
    }

    // Token Config.
    /// Initialize a new token map account with its store set to [`store`](InitializeTokenMap::store).
    ///
    /// Anyone can initialize a token map account without any permissions, but after initialization, only
    /// addresses authorized by the store can modify this token map.
    ///
    /// # Accounts
    /// [*See the documentation for the accounts*](InitializeTokenMap).
    ///
    /// # Checks
    /// - The [`payer`](InitializeTokenMap::payer) must be a signer.
    /// - The [`store`](InitializeTokenMap::store) must be an initialized [`Store`](states::Store)
    /// account owned by the store program.
    /// - The [`token_map`](InitializeTokenMap::token_map) must be a uninitialized account.
    pub fn initialize_token_map(ctx: Context<InitializeTokenMap>) -> Result<()> {
        instructions::initialize_token_map(ctx)
    }

    /// Push a new token config to the given token map.
    ///
    /// This instruction is used to add or update the token config for an existing token,
    /// where its `token_decimals` will naturally be set to the decimals of this token.
    ///
    /// # Accounts
    /// [*See the documentation for the accounts*](PushToTokenMap).
    ///
    /// # Arguments
    /// - `name`: The name of token.
    /// - `builder`: Builder for the token config.
    /// - `enable`: Whether the token config should be enabled/disabled after the push.
    /// - `new`: Enforce insert if new = true, and an error will be returned if the config
    /// for the given token already exists.
    ///
    /// # Checks
    /// - The [`authority`](PushToTokenMap::authority) must be a signer and a MARKET_KEEPER
    /// of the given store.
    /// - The [`store`](PushToTokenMap::store) must be an initialized [`Store`](states::Store)
    /// account owned by the store program. And it must be the owner of the token map.
    /// - The [`token_map`](PushToTokenMap::token_map) must be an initialized token map account
    /// owned by the store program.
    /// - The [`token`](PushToTokenMap::token) must be an initialized token mint account owned
    /// by the SPL token program.
    #[access_control(internal::Authenticate::only_market_keeper(&ctx))]
    pub fn push_to_token_map(
        ctx: Context<PushToTokenMap>,
        name: String,
        builder: TokenConfigBuilder,
        enable: bool,
        new: bool,
    ) -> Result<()> {
        instructions::unchecked_push_to_token_map(ctx, &name, builder, enable, new)
    }

    /// Push a new synthetic token config to the given token map.
    ///
    /// This instruction can set or update the token config for a non-existent token.
    /// Its token decimals are determined by the corresponding argument.
    ///
    /// # Accounts
    /// [*See the documentation for the accounts*](PushToTokenMapSynthetic).
    ///
    /// # Arguments
    /// - `name`: The name of synthetic token.
    /// - `token`: The address of the synthetic token.
    /// - `token_decimals`: The token decimals to use for the synthetic token.
    /// - `builder`: Builder for the token config.
    /// - `enable`: Whether the token config should be enabled/disabled after the push.
    /// - `new`: Enforce insert if new = true, and an error will be returned if the config
    /// for the given token already exists.
    ///
    /// # Checks
    /// - The [`authority`](PushToTokenMapSynthetic::authority) must be a signer and a MARKET_KEEPER
    /// of the given store.
    /// - The [`store`](PushToTokenMapSynthetic::store) must be an initialized [`Store`](states::Store)
    /// account owned by the store program. And it must be the owner of the token map.
    /// - The [`token_map`](PushToTokenMapSynthetic::token_map) must be an initialized token map account
    /// owned by the store program.
    #[access_control(internal::Authenticate::only_market_keeper(&ctx))]
    pub fn push_to_token_map_synthetic(
        ctx: Context<PushToTokenMapSynthetic>,
        name: String,
        token: Pubkey,
        token_decimals: u8,
        builder: TokenConfigBuilder,
        enable: bool,
        new: bool,
    ) -> Result<()> {
        instructions::unchecked_push_to_token_map_synthetic(
            ctx,
            &name,
            token,
            token_decimals,
            builder,
            enable,
            new,
        )
    }

    pub fn is_token_config_enabled(ctx: Context<ReadTokenMap>, token: Pubkey) -> Result<bool> {
        instructions::is_token_config_enabled(ctx, &token)
    }

    pub fn token_expected_provider(ctx: Context<ReadTokenMap>, token: Pubkey) -> Result<u8> {
        instructions::token_expected_provider(ctx, &token).map(|kind| kind as u8)
    }

    pub fn token_feed(ctx: Context<ReadTokenMap>, token: Pubkey, provider: u8) -> Result<Pubkey> {
        instructions::token_feed(
            ctx,
            &token,
            &PriceProviderKind::try_from(provider)
                .map_err(|_| StoreError::InvalidProviderKindIndex)?,
        )
    }

    pub fn token_timestamp_adjustment(
        ctx: Context<ReadTokenMap>,
        token: Pubkey,
        provider: u8,
    ) -> Result<u32> {
        instructions::token_timestamp_adjustment(
            ctx,
            &token,
            &PriceProviderKind::try_from(provider)
                .map_err(|_| StoreError::InvalidProviderKindIndex)?,
        )
    }

    pub fn token_name(ctx: Context<ReadTokenMap>, token: Pubkey) -> Result<String> {
        instructions::token_name(ctx, &token)
    }

    pub fn token_decimals(ctx: Context<ReadTokenMap>, token: Pubkey) -> Result<u8> {
        instructions::token_decimals(ctx, &token)
    }

    pub fn token_precision(ctx: Context<ReadTokenMap>, token: Pubkey) -> Result<u8> {
        instructions::token_precision(ctx, &token)
    }

    /// Enable of disable the config for the given token.
    ///
    /// # Accounts
    /// [*See the documentation for the accounts*](ToggleTokenConfig).
    ///
    /// # Arguments
    /// - `token`: The token whose config will be updated.
    /// - `enable`: Enable or diable the config.
    ///
    /// # Checks
    /// - The [`authority`](ToggleTokenConfig::authority) must be a signer
    /// and a MARKET_KEEPER of the give store.
    /// - The [`store`](ToggleTokenConfig::store) must be an initialized [`Store`](states::Store)
    /// account owned by the store program. And it must be the owner of the token map.
    /// - The [`token_map`](ToggleTokenConfig::token_map) must be an initialized token map account
    /// owned by the store program.
    /// - The given `token` must exist in the token map.
    #[access_control(internal::Authenticate::only_market_keeper(&ctx))]
    pub fn toggle_token_config(
        ctx: Context<ToggleTokenConfig>,
        token: Pubkey,
        enable: bool,
    ) -> Result<()> {
        instructions::unchecked_toggle_token_config(ctx, token, enable)
    }

    /// Set the expected provider for the given token.
    ///
    /// # Accounts
    /// [*See the documentation for the accounts*](SetExpectedProvider).
    ///
    /// # Arguments
    /// - `token`: The token whose config will be updated.
    /// - `provider`: The provider index to be set as the expected provider
    /// for the token. See also [`PriceProviderKind`].
    ///
    /// # Checks
    /// - The [`authority`](SetExpectedProvider::authority) must be a signer
    /// and a MARKET_KEEPER of the give store.
    /// - The [`store`](SetExpectedProvider::store) must be an initialized [`Store`](states::Store)
    /// account owned by the store program. And it must be the owner of the token map.
    /// - The [`token_map`](SetExpectedProvider::token_map) must be an initialized token map account
    /// owned by the store program.
    /// - The given `token` must exist in the token map.
    /// - The index of the provider must be valid.
    #[access_control(internal::Authenticate::only_market_keeper(&ctx))]
    pub fn set_expected_provider(
        ctx: Context<SetExpectedProvider>,
        token: Pubkey,
        provider: u8,
    ) -> Result<()> {
        instructions::unchecked_set_expected_provider(
            ctx,
            token,
            PriceProviderKind::try_from(provider)
                .map_err(|_| StoreError::InvalidProviderKindIndex)?,
        )
    }

    /// Set the feed config of the given provider for the given token.
    ///
    /// # Accounts
    /// [*See the documentation for the accounts*](SetFeedConfig).
    ///
    /// # Arguments
    /// - `token`: The token whose config will be updated.
    /// - `provider`: The index of the provider whose feed config will be updated.
    /// - `feed`: The new feed address.
    /// - `timestamp_adjustment`: The new timestamp adjustment seconds.
    ///
    /// # Checks
    /// - The [`authority`](SetFeedConfig::authority) must be a signer
    /// and a MARKET_KEEPER of the give store.
    /// - The [`store`](SetFeedConfig::store) must be an initialized [`Store`](states::Store)
    /// account owned by the store program. And it must be the owner of the token map.
    /// - The [`token_map`](SetFeedConfig::token_map) must be an initialized token map account
    /// owned by the store program.
    /// - The given `token` must exist in the token map.
    /// - The index of the provider must be valid.
    #[access_control(internal::Authenticate::only_market_keeper(&ctx))]
    pub fn set_feed_config(
        ctx: Context<SetFeedConfig>,
        token: Pubkey,
        provider: u8,
        feed: Pubkey,
        timestamp_adjustment: u32,
    ) -> Result<()> {
        instructions::unchecked_set_feed_config(
            ctx,
            token,
            &PriceProviderKind::try_from(provider)
                .map_err(|_| StoreError::InvalidProviderKindIndex)?,
            feed,
            timestamp_adjustment,
        )
    }

    // Market.
    /// Initialize a [`Market`](states::Market) account.
    ///
    /// # Accounts
    /// [*See the documentation for the accounts.*](InitializeMarket)
    ///
    /// # Arguments
    /// - `market_token_mint`: The address of the corresponding market token.
    /// - `index_token_mint`: The address of the index token.
    /// - `long_token_mint`: The address of the long token.
    /// - `short_token_mint`: The address of the short token.
    /// - `name`: The name of the market.
    /// - `enable`: Whether to enable the market after initialization.
    ///
    /// # Checks
    /// - *TODO*
    #[access_control(internal::Authenticate::only_market_keeper(&ctx))]
    pub fn initialize_market(
        ctx: Context<InitializeMarket>,
        market_token_mint: Pubkey,
        index_token_mint: Pubkey,
        long_token_mint: Pubkey,
        short_token_mint: Pubkey,
        name: String,
        enable: bool,
    ) -> Result<()> {
        instructions::unchecked_initialize_market(
            ctx,
            market_token_mint,
            index_token_mint,
            long_token_mint,
            short_token_mint,
            &name,
            enable,
        )
    }

    /// Close a [`Market`](states::Market) account.
    ///
    /// # Accounts
    /// [*See the documentation for the accounts.*](RemoveMarket)
    ///
    /// # Checks
    /// - *TODO*
    #[access_control(internal::Authenticate::only_market_keeper(&ctx))]
    pub fn remove_market(ctx: Context<RemoveMarket>) -> Result<()> {
        instructions::unchecked_remove_market(ctx)
    }

    /// Validate the market and returns its [meta](states::MarketMeta).
    ///
    /// # Accounts
    /// [*See the documentation for the accounts.*](GetValidatedMarketMeta)
    ///
    /// # Checks
    /// - *TODO*
    pub fn get_validated_market_meta(ctx: Context<GetValidatedMarketMeta>) -> Result<MarketMeta> {
        instructions::get_validated_market_meta(ctx)
    }

    /// Transfer tokens into the market and record in its balance.
    ///
    /// # Accounts
    /// [*See the documentation for the accounts.*](MarketTransferIn)
    ///
    /// # Arguments
    /// - `amount`: The amount to transfer in.
    ///
    /// # Checks
    /// - *TODO*
    #[access_control(internal::Authenticate::only_controller(&ctx))]
    pub fn market_transfer_in(ctx: Context<MarketTransferIn>, amount: u64) -> Result<()> {
        instructions::unchecked_market_transfer_in(ctx, amount)
    }

    /// Transfer tokens out from the market and record in its balance.
    ///
    /// # Accounts
    /// [*See the documentation for the accounts.*](MarketTransferOut)
    ///
    /// # Arguments
    /// - `amount`: The amount to transfer out.
    ///
    /// # Checks
    /// - *TODO*
    #[access_control(internal::Authenticate::only_controller(&ctx))]
    pub fn market_transfer_out(ctx: Context<MarketTransferOut>, amount: u64) -> Result<()> {
        instructions::unchecked_market_transfer_out(ctx, amount)
    }

    /// Get the [meta](states::MarketMeta) of the market without validation.
    ///
    /// # Accounts
    /// [*See the documentation for the accounts.*](ReadMarket)
    ///
    pub fn get_market_meta(ctx: Context<ReadMarket>) -> Result<MarketMeta> {
        instructions::get_market_meta(ctx)
    }

    /// Read an item from the market config by the key.
    ///
    /// # Accounts
    /// [*See the documentation for the accounts.*](ReadMarket)
    ///
    /// # Arguments
    /// - `key`: The key of the config item.
    pub fn get_market_config(ctx: Context<ReadMarket>, key: String) -> Result<u128> {
        instructions::get_market_config(ctx, &key)
    }

    /// Read current market status.
    ///
    /// # Accounts
    /// [*See the documentation for the accounts.*](ReadMarket)
    ///
    /// # Arguments
    /// - `prices`: The unit prices of tokens.
    /// - `maximize_pnl`: Whether to maximize the PnL.
    /// - `maximize_pool_value`: Whether to maximize the pool value.
    pub fn get_market_status(
        ctx: Context<ReadMarket>,
        prices: Prices<u128>,
        maximize_pnl: bool,
        maximize_pool_value: bool,
    ) -> Result<MarketStatus> {
        instructions::get_market_status(ctx, &prices, maximize_pnl, maximize_pool_value)
    }

    /// Get current market token price.
    ///
    /// # Accounts
    /// [*See the documentation for the accounts.*](ReadMarket)
    ///
    /// # Arguments
    /// - `prices`: The unit prices of tokens.
    /// - `maximize_pnl`: Whether to maximize the PnL.
    /// - `maximize_pool_value`: Whether to maximize the pool value.
    pub fn get_market_token_price(
        ctx: Context<ReadMarketWithToken>,
        prices: Prices<u128>,
        pnl_factor: String,
        maximize: bool,
    ) -> Result<u128> {
        instructions::get_market_token_price(
            ctx,
            &prices,
            pnl_factor
                .parse()
                .map_err(|_| error!(StoreError::InvalidArgument))?,
            maximize,
        )
    }

    /// Update an item in the market config.
    ///
    /// # Accounts
    /// [*See the documentation for the accounts.*](UpdateMarketConfig)
    ///
    /// # Arguments
    /// - `key`: The key of the config item.
    /// - `value`: The value to update the config item to.
    ///
    /// # Checks
    /// - *TODO*
    #[access_control(internal::Authenticate::only_market_keeper(&ctx))]
    pub fn update_market_config(
        ctx: Context<UpdateMarketConfig>,
        key: String,
        value: u128,
    ) -> Result<()> {
        instructions::unchecked_update_market_config(ctx, &key, value)
    }

    /// Update the market config with the given
    /// [`MarketConfigBuffer`](states::MarketConfigBuffer) account.
    ///
    /// # Accounts
    /// [*See the documentation for the accounts.*](UpdateMarketConfigWithBuffer)
    ///
    /// # Checks
    /// - *TODO*
    #[access_control(internal::Authenticate::only_market_keeper(&ctx))]
    pub fn update_market_config_with_buffer(
        ctx: Context<UpdateMarketConfigWithBuffer>,
    ) -> Result<()> {
        instructions::unchecked_update_market_config_with_buffer(ctx)
    }

    /// Initialize a market config buffer account.
    ///
    /// # Accounts
    /// [*See the documentation for the accounts.*](InitializeMarketConfigBuffer)
    ///
    /// # Arguments
    /// - `expire_after_secs`: The expiration time of the buffer in seconds.
    ///
    /// # Checks
    /// - *TODO*
    pub fn initialize_market_config_buffer(
        ctx: Context<InitializeMarketConfigBuffer>,
        expire_after_secs: u32,
    ) -> Result<()> {
        instructions::initialize_market_config_buffer(ctx, expire_after_secs)
    }

    /// Replace the authority of the market config buffer account
    /// with the new one.
    ///
    /// # Accounts
    /// [*See the documentation for the accounts.*](SetMarketConfigBufferAuthority)
    ///
    /// # Arguments
    /// - `new_authority`: The new authority.
    ///
    /// # Checks
    /// - *TODO*
    pub fn set_market_config_buffer_authority(
        ctx: Context<SetMarketConfigBufferAuthority>,
        new_authority: Pubkey,
    ) -> Result<()> {
        instructions::set_market_config_buffer_authority(ctx, new_authority)
    }

    /// Close the given market config buffer account.
    ///
    /// # Accounts
    /// [*See the documentation for the accounts.*](CloseMarketConfigBuffer)
    ///
    /// # Checks
    /// - *TODO*
    pub fn close_market_config_buffer(ctx: Context<CloseMarketConfigBuffer>) -> Result<()> {
        instructions::close_market_config_buffer(ctx)
    }

    /// Push config items to the given market config buffer account.
    ///
    /// # Accounts
    /// [*See the documentation for the accounts.*](PushToMarketConfigBuffer)
    ///
    /// # Arguments
    /// - `new_configs`: The list of new config items.
    ///
    /// # Checks
    /// - *TODO*
    pub fn push_to_market_config_buffer(
        ctx: Context<PushToMarketConfigBuffer>,
        new_configs: Vec<EntryArgs>,
    ) -> Result<()> {
        instructions::push_to_market_config_buffer(ctx, new_configs)
    }

    /// Enable or diable the given market.
    ///
    /// # Accounts
    /// [*See the documentation for the accounts.*](ToggleMarket)
    ///
    /// # Arguments
    /// - `enable`: Whether to enable or disable the market.
    ///
    /// # Checks
    /// - *TODO*
    #[access_control(internal::Authenticate::only_market_keeper(&ctx))]
    pub fn toggle_market(ctx: Context<ToggleMarket>, enable: bool) -> Result<()> {
        instructions::unchecked_toggle_market(ctx, enable)
    }

    /// Claim fees from the given market. The claimed amount remains in the market balance,
    /// and requires a subsequent transfer.
    ///
    /// # Accounts
    /// [*See the documentation for the accounts.*](ClaimFeesFromMarket)
    ///
    /// # Arguments
    /// - `token`: The token to claim.
    ///
    /// # Return
    /// - Returns the amount to be claimed.
    ///
    /// # Errors
    /// - The [`authority`](ClaimFeesFromMarket) must be a signer and a CONTROLLER
    /// in the given store.
    /// - The [`store`](ClaimFeesFromMarket) must be an initialized [`Store`](crate::states::Store)
    /// account owned by this store program.
    /// - The [`market`](ClaimFeesFromMarket) must be an initialized [`Market`](crate::states::Market)
    /// account owned by this store program, whose the store must be the given one.
    /// - The `token` must be one of the collateral token.
    /// - The market balance validation must pass after the claim.
    #[access_control(internal::Authenticate::only_controller(&ctx))]
    pub fn claim_fees_from_market(ctx: Context<ClaimFeesFromMarket>, token: Pubkey) -> Result<u64> {
        let claimed = instructions::unchecked_claim_fees_from_market(ctx, &token)
            .map_err(ModelError::from)?;
        Ok(claimed)
    }

    // Token.
    /// Initialize a new market token.
    ///
    /// # Accounts
    /// [*See the documentation for the accounts.*](InitializeMarketToken)
    ///
    /// # Arguments
    /// - `index_token_mint`: The address of the index token.
    /// - `long_token_mint`: The address of the long token.
    /// - `short_token_mint`: The address of the short token.
    ///
    /// # Checks
    /// - *TODO*
    #[access_control(internal::Authenticate::only_market_keeper(&ctx))]
    pub fn initialize_market_token(
        ctx: Context<InitializeMarketToken>,
        index_token_mint: Pubkey,
        long_token_mint: Pubkey,
        short_token_mint: Pubkey,
    ) -> Result<()> {
        instructions::unchecked_initialize_market_token(
            ctx,
            index_token_mint,
            long_token_mint,
            short_token_mint,
        )
    }

    /// Mint the given amount of market tokens to the destination account.
    ///
    /// # Accounts
    /// [*See the documentation for the accounts.*](MintMarketTokenTo)
    ///
    /// # Arguments
    /// - `amount`: The amount to mint.
    ///
    /// # Checks
    /// - *TODO*
    #[access_control(internal::Authenticate::only_controller(&ctx))]
    pub fn mint_market_token_to(ctx: Context<MintMarketTokenTo>, amount: u64) -> Result<()> {
        instructions::unchecked_mint_market_token_to(ctx, amount)
    }

    /// Burn the given amount of market tokens from the given account.
    ///
    /// # Accounts
    /// [*See the documentation for the accounts.*](BurnMarketTokenFrom)
    ///
    /// # Arguments
    /// - `amount`: The amount to burn.
    ///
    /// # Checks
    /// - *TODO*
    #[access_control(internal::Authenticate::only_controller(&ctx))]
    pub fn burn_market_token_from(ctx: Context<BurnMarketTokenFrom>, amount: u64) -> Result<()> {
        instructions::unchecked_burn_market_token_from(ctx, amount)
    }

    /// Initialize the market vault for the given token.
    ///
    /// # Accounts
    /// [*See the documentation for the accounts.*](InitializeMarketVault)
    ///
    /// # Arguments
    /// - `market_token_mint`: (*deprecated*) The market that owns this vault.
    ///
    /// # Checks
    /// - *TODO*
    #[access_control(internal::Authenticate::only_market_keeper(&ctx))]
    pub fn initialize_market_vault(
        ctx: Context<InitializeMarketVault>,
        market_token_mint: Option<Pubkey>,
    ) -> Result<()> {
        instructions::unchecked_initialize_market_vault(ctx, market_token_mint)
    }

    /// Transfer the given amount of tokens out to the destination account.
    ///
    /// # Accounts
    /// [*See the documentation for the accounts.*](MarketVaultTransferOut)
    ///
    /// # Arguments
    /// - `amount`: The amount to transfer.
    ///
    /// # Checks
    /// - *TODO*
    #[access_control(internal::Authenticate::only_controller(&ctx))]
    pub fn market_vault_transfer_out(
        ctx: Context<MarketVaultTransferOut>,
        amount: u64,
    ) -> Result<()> {
        instructions::unchecked_market_vault_transfer_out(ctx, amount)
    }

    #[access_control(internal::Authenticate::only_order_keeper(&ctx))]
    pub fn use_claimable_account(
        ctx: Context<UseClaimableAccount>,
        timestamp: i64,
        amount: u64,
    ) -> Result<()> {
        instructions::unchecked_use_claimable_account(ctx, timestamp, amount)
    }

    #[access_control(internal::Authenticate::only_order_keeper(&ctx))]
    pub fn close_empty_claimable_account(
        ctx: Context<CloseEmptyClaimableAccount>,
        user: Pubkey,
        timestamp: i64,
    ) -> Result<()> {
        instructions::unchecked_close_empty_claimable_account(ctx, user, timestamp)
    }

    /// Prepare an associated token account.
    ///
    /// # Accounts
    /// *[See the documentation for the accounts.](PrepareAssociatedTokenAccount).*
    ///
    /// # Checks
    /// - The [`payer`](PrepareAssociatedTokenAccount::payer) must be a signer.
    /// - The [`mint`](PrepareAssociatedTokenAccount::mint) must be a
    /// [`Mint`](anchor_spl::token::Mint) account.
    /// - The [`account`] must be an associated token account with mint = `mint`
    /// and owner = `owner`. It can be uninitialized.
    pub fn prepare_associated_token_account(
        ctx: Context<PrepareAssociatedTokenAccount>,
    ) -> Result<()> {
        instructions::prepare_associated_token_account(ctx)
    }

    // Oracle.
    /// Initailize a new oracle account for the given store with the given index.
    ///
    /// # Accounts
    /// *[See the documentation for the accounts.](InitializeOracle).*
    ///
    /// # Arguments
    /// - `index`: The oracle index to use.
    ///
    /// # Checks
    /// - The [`authority`](InitializeOracle::authority) must be a signer and a MARKET_KEEPER of the store.
    /// - The [`store`](InitializeOracle::store) must be an initialized [`Store`](states::Store)
    /// account owned by the store program. And it must be the owner of the token map.
    /// - The [`oralce`](InitializeOracle::oracle) account must be uninitialized and its address must be the PDA
    /// derived from the oracle account seed [`SEED`](states::Oracle::SEED), the `store` address and
    /// the `index`.
    #[access_control(internal::Authenticate::only_market_keeper(&ctx))]
    pub fn initialize_oracle(ctx: Context<InitializeOracle>, index: u8) -> Result<()> {
        instructions::unchecked_initialize_oracle(ctx, index)
    }

    #[access_control(internal::Authenticate::only_controller(&ctx))]
    pub fn clear_all_prices(ctx: Context<ClearAllPrices>) -> Result<()> {
        instructions::clear_all_prices(ctx)
    }

    #[access_control(internal::Authenticate::only_controller(&ctx))]
    pub fn set_price(ctx: Context<SetPrice>, token: Pubkey, price: Price) -> Result<()> {
        instructions::set_price(ctx, token, price)
    }

    #[access_control(internal::Authenticate::only_controller(&ctx))]
    pub fn set_prices_from_price_feed<'info>(
        ctx: Context<'_, '_, 'info, 'info, SetPricesFromPriceFeed<'info>>,
        tokens: Vec<Pubkey>,
    ) -> Result<()> {
        instructions::set_prices_from_price_feed(ctx, tokens)
    }

    // Deposit.
    #[access_control(internal::Authenticate::only_controller(&ctx))]
    pub fn initialize_deposit(
        ctx: Context<InitializeDeposit>,
        nonce: [u8; 32],
        tokens_with_feed: Vec<TokenRecord>,
        swap_params: SwapParams,
        token_params: DepositTokenParams,
        ui_fee_receiver: Pubkey,
    ) -> Result<()> {
        instructions::initialize_deposit(
            ctx,
            nonce,
            tokens_with_feed,
            swap_params,
            token_params,
            ui_fee_receiver,
        )
    }

    #[access_control(internal::Authenticate::only_controller(&ctx))]
    pub fn remove_deposit(ctx: Context<RemoveDeposit>, refund: u64, reason: String) -> Result<()> {
        instructions::remove_deposit(ctx, refund, &reason)
    }

    // Withdrawal.
    #[access_control(internal::Authenticate::only_controller(&ctx))]
    pub fn initialize_withdrawal(
        ctx: Context<InitializeWithdrawal>,
        nonce: [u8; 32],
        swap_params: SwapParams,
        tokens_with_feed: Vec<TokenRecord>,
        token_params: WithdrawalTokenParams,
        market_token_amount: u64,
        ui_fee_receiver: Pubkey,
    ) -> Result<()> {
        instructions::initialize_withdrawal(
            ctx,
            nonce,
            swap_params,
            tokens_with_feed,
            token_params,
            market_token_amount,
            ui_fee_receiver,
        )
    }

    #[access_control(internal::Authenticate::only_controller(&ctx))]
    pub fn remove_withdrawal(
        ctx: Context<RemoveWithdrawal>,
        refund: u64,
        reason: String,
    ) -> Result<()> {
        instructions::remove_withdrawal(ctx, refund, &reason)
    }

    // Exchange.
    #[access_control(internal::Authenticate::only_controller(&ctx))]
    pub fn execute_deposit<'info>(
        ctx: Context<'_, '_, 'info, 'info, ExecuteDeposit<'info>>,
        throw_on_execution_error: bool,
    ) -> Result<bool> {
        instructions::execute_deposit(ctx, throw_on_execution_error)
    }

    #[access_control(internal::Authenticate::only_controller(&ctx))]
    pub fn execute_withdrawal<'info>(
        ctx: Context<'_, '_, 'info, 'info, ExecuteWithdrawal<'info>>,
        throw_on_execution_error: bool,
    ) -> Result<(u64, u64)> {
        instructions::execute_withdrawal(ctx, throw_on_execution_error)
    }

    /// Update the ADL state for the market.
    ///
    /// # Accounts.
    /// *[See the documentation for the accounts.](UpdateAdlState).*
    ///
    /// # Arguments
    /// - `is_long`: The market side to update for.
    ///
    /// # Checks
    /// - The [`authority`](UpdateAdlState::authority) must be a signer and a
    /// CONTROLLER of the store.
    /// - The [`store`](UpdateAdlState::store) must be an initialized [`Store`](states::Store)
    /// account owned by the store program.
    /// - The [`oracle`](UpdateAdlState::oracle) must be an initialized [`Oracle`](states::Oracle)
    /// account owned by the store program, and it must be owned by the store.
    /// - The [`market`](UpdateAdlState::market) must be enabled and owned by the store.
    #[access_control(internal::Authenticate::only_controller(&ctx))]
    pub fn update_adl_state(ctx: Context<UpdateAdlState>, is_long: bool) -> Result<()> {
        instructions::unchecked_update_adl_state(ctx, is_long)
    }

    // Order.
    #[access_control(internal::Authenticate::only_controller(&ctx))]
    pub fn initialize_order(
        ctx: Context<InitializeOrder>,
        owner: Pubkey,
        nonce: [u8; 32],
        tokens_with_feed: Vec<TokenRecord>,
        swap: SwapParams,
        params: OrderParams,
        output_token: Pubkey,
        ui_fee_receiver: Pubkey,
    ) -> Result<()> {
        instructions::initialize_order(
            ctx,
            owner,
            nonce,
            tokens_with_feed,
            swap,
            params,
            output_token,
            ui_fee_receiver,
        )
    }

    #[access_control(internal::Authenticate::only_controller(&ctx))]
    pub fn remove_order(ctx: Context<RemoveOrder>, refund: u64, reason: String) -> Result<()> {
        instructions::remove_order(ctx, refund, &reason)
    }

    #[access_control(internal::Authenticate::only_controller(&ctx))]
    pub fn update_order(ctx: Context<UpdateOrder>, params: UpdateOrderParams) -> Result<()> {
        instructions::unchecked_update_order(ctx, &params)
    }

    // Position.
    #[access_control(internal::Authenticate::only_controller(&ctx))]
    pub fn remove_position(ctx: Context<RemovePosition>, refund: u64) -> Result<()> {
        instructions::remove_position(ctx, refund)
    }

    #[cfg(not(feature = "no-bug-fix"))]
    #[access_control(internal::Authenticate::only_market_keeper(&ctx))]
    pub fn turn_into_pure_pool(ctx: Context<TurnPureFlag>, kind: u8) -> Result<()> {
        instructions::unchecked_turn_into_pure_pool(
            ctx,
            kind.try_into()
                .map_err(|_| error!(StoreError::InvalidArgument))?,
        )
    }

    #[cfg(not(feature = "no-bug-fix"))]
    #[access_control(internal::Authenticate::only_market_keeper(&ctx))]
    pub fn turn_into_impure_pool(ctx: Context<TurnPureFlag>, kind: u8) -> Result<()> {
        instructions::unchecked_turn_into_impure_pool(
            ctx,
            kind.try_into()
                .map_err(|_| error!(StoreError::InvalidArgument))?,
        )
    }

    // Exchange.
    pub fn prepare_deposit_escrow(
        ctx: Context<PrepareDepositEscrow>,
        nonce: [u8; 32],
    ) -> Result<()> {
        instructions::prepare_deposit_escrow(ctx, nonce)
    }

    pub fn create_deposit<'info>(
        ctx: Context<'_, '_, 'info, 'info, CreateDeposit<'info>>,
        nonce: [u8; 32],
        params: CreateDepositParams,
    ) -> Result<()> {
        instructions::create_deposit(ctx, nonce, &params)
    }

    pub fn close_deposit(ctx: Context<CloseDeposit>, reason: String) -> Result<()> {
        instructions::close_deposit(ctx, &reason)
    }

    #[access_control(internal::Authenticate::only_order_keeper(&ctx))]
    pub fn execute_deposit_v2<'info>(
        ctx: Context<'_, '_, 'info, 'info, ExecuteDepositV2<'info>>,
        execution_fee: u64,
        throw_on_execution_error: bool,
    ) -> Result<()> {
        instructions::unchecked_execute_deposit(ctx, execution_fee, throw_on_execution_error)
    }

    pub fn prepare_withdrawal_escrow(
        ctx: Context<PrepareWithdrawalEscrow>,
        nonce: [u8; 32],
    ) -> Result<()> {
        instructions::prepare_withdrawal_escrow(ctx, nonce)
    }

    pub fn create_withdrawal<'info>(
        ctx: Context<'_, '_, 'info, 'info, CreateWithdrawal<'info>>,
        nonce: [u8; 32],
        params: CreateWithdrawalParams,
    ) -> Result<()> {
        instructions::create_withdrawal(ctx, nonce, &params)
    }

    pub fn close_withdrawal(ctx: Context<CloseWithdrawal>, reason: String) -> Result<()> {
        instructions::close_withdrawal(ctx, &reason)
    }

    #[access_control(internal::Authenticate::only_order_keeper(&ctx))]
    pub fn execute_withdrawal_v2<'info>(
        ctx: Context<'_, '_, 'info, 'info, ExecuteWithdrawalV2<'info>>,
        execution_fee: u64,
        throw_on_execution_error: bool,
    ) -> Result<()> {
        instructions::unchecked_execute_withdrawal(ctx, execution_fee, throw_on_execution_error)
    }

    pub fn prepare_swap_order_escrow(
        ctx: Context<PrepareSwapOrderEscrow>,
        nonce: [u8; 32],
    ) -> Result<()> {
        instructions::prepare_swap_order_escrow(ctx, nonce)
    }

    pub fn prepare_increase_order_escrow(
        ctx: Context<PrepareIncreaseOrderEscrow>,
        nonce: [u8; 32],
    ) -> Result<()> {
        instructions::prepare_increase_order_escrow(ctx, nonce)
    }

    pub fn prepare_decrease_order_escrow(
        ctx: Context<PrepareDecreaseOrderEscrow>,
        nonce: [u8; 32],
    ) -> Result<()> {
        instructions::prepare_decrease_order_escrow(ctx, nonce)
    }

    pub fn prepare_position(
        ctx: Context<PreparePosition>,
        params: CreateOrderParams,
    ) -> Result<()> {
        instructions::prepare_position(ctx, &params)
    }

    pub fn create_order<'info>(
        ctx: Context<'_, '_, 'info, 'info, CreateOrder<'info>>,
        nonce: [u8; 32],
        params: CreateOrderParams,
    ) -> Result<()> {
        instructions::create_order(ctx, &nonce, &params)
    }

    pub fn close_order(ctx: Context<CloseOrder>, reason: String) -> Result<()> {
        instructions::close_order(ctx, &reason)
    }

    pub fn prepare_trade_event_buffer(
        ctx: Context<PrepareTradeEventBuffer>,
        index: u8,
    ) -> Result<()> {
        instructions::prepare_trade_event_buffer(ctx, index)
    }

    #[access_control(internal::Authenticate::only_order_keeper(&ctx))]
    pub fn execute_order_v2<'info>(
        ctx: Context<'_, '_, 'info, 'info, ExecuteOrderV2<'info>>,
        recent_timestamp: i64,
        execution_fee: u64,
        throw_on_execution_error: bool,
    ) -> Result<()> {
        instructions::unchecked_execute_order(
            ctx,
            recent_timestamp,
            execution_fee,
            throw_on_execution_error,
        )
    }

    #[access_control(internal::Authenticate::only_order_keeper(&ctx))]
    pub fn execute_decrease_order<'info>(
        ctx: Context<'_, '_, 'info, 'info, ExecuteDecreaseOrder<'info>>,
        recent_timestamp: i64,
        execution_fee: u64,
        throw_on_execution_error: bool,
    ) -> Result<()> {
        instructions::unchecked_execute_decrease_order(
            ctx,
            recent_timestamp,
            execution_fee,
            throw_on_execution_error,
        )
    }

    #[access_control(internal::Authenticate::only_order_keeper(&ctx))]
    pub fn liquidate<'info>(
        ctx: Context<'_, '_, 'info, 'info, PositionCut<'info>>,
        nonce: [u8; 32],
        recent_timestamp: i64,
        execution_fee: u64,
    ) -> Result<()> {
        instructions::unchecked_process_position_cut(
            ctx,
            &nonce,
            recent_timestamp,
            PositionCutKind::Liquidate,
            execution_fee,
        )
    }

    #[access_control(internal::Authenticate::only_order_keeper(&ctx))]
    pub fn auto_deleverage<'info>(
        ctx: Context<'_, '_, 'info, 'info, PositionCut<'info>>,
        nonce: [u8; 32],
        recent_timestamp: i64,
        size_delta_in_usd: u128,
        execution_fee: u64,
    ) -> Result<()> {
        instructions::unchecked_process_position_cut(
            ctx,
            &nonce,
            recent_timestamp,
            PositionCutKind::AutoDeleverage(size_delta_in_usd),
            execution_fee,
        )
    }

    pub fn prepare_shift_escrow(ctx: Context<PrepareShiftEscorw>, nonce: [u8; 32]) -> Result<()> {
        instructions::prepare_shift_escrow(ctx, nonce)
    }

    pub fn create_shift<'info>(
        ctx: Context<'_, '_, 'info, 'info, CreateShift<'info>>,
        nonce: [u8; 32],
        params: CreateShiftParams,
    ) -> Result<()> {
        instructions::create_shift(ctx, &nonce, &params)
    }

    /// Execute Shift.
    #[access_control(internal::Authenticate::only_order_keeper(&ctx))]
    pub fn execute_shift<'info>(
        ctx: Context<'_, '_, 'info, 'info, ExecuteShift<'info>>,
        execution_lamports: u64,
        throw_on_execution_error: bool,
    ) -> Result<()> {
        instructions::unchecked_execute_shift(ctx, execution_lamports, throw_on_execution_error)
    }

    pub fn close_shift(ctx: Context<CloseShift>, reason: String) -> Result<()> {
        instructions::close_shift(ctx, &reason)
    }

    /// Initialize GT Mint.
    #[access_control(internal::Authenticate::only_market_keeper(&ctx))]
    pub fn initialize_gt(
        ctx: Context<InitializeGT>,
        decimals: u8,
        initial_mint_cost: u128,
        grow_factor: u128,
        grow_step: u64,
    ) -> Result<()> {
        instructions::unchecked_initialize_gt(
            ctx,
            decimals,
            initial_mint_cost,
            grow_factor,
            grow_step,
        )
    }
}

#[error_code]
pub enum StoreError {
    // Common.
    #[msg("Invalid pda")]
    InvalidPDA,
    #[msg("Invalid key")]
    InvalidKey,
    #[msg("Already exist")]
    AlreadyExist,
    #[msg("Exceed max length limit")]
    ExceedMaxLengthLimit,
    #[msg("Exceed max string length limit")]
    ExceedMaxStringLengthLimit,
    #[msg("No space for new data")]
    NoSpaceForNewData,
    #[msg("Invalid argument")]
    InvalidArgument,
    #[msg("Lamports not enough")]
    LamportsNotEnough,
    #[msg("Required resource not found")]
    RequiredResourceNotFound,
    #[msg("Amount overflow")]
    AmountOverflow,
    #[msg("Unknown error")]
    Unknown,
    #[msg("Gmx Core Error")]
    Model,
    #[msg("Missing amount")]
    MissingAmount,
    #[msg("Missing factor")]
    MissingFactor,
    #[msg("Cannot be zero")]
    CannotBeZero,
    #[msg("Missing Market Account")]
    MissingMarketAccount,
    #[msg("Load Account Error")]
    LoadAccountError,
    // Roles.
    #[msg("Too many admins")]
    TooManyAdmins,
    #[msg("At least one admin")]
    AtLeastOneAdmin,
    #[msg("Invalid data store")]
    InvalidDataStore,
    #[msg("Already be an admin")]
    AlreadyBeAnAdmin,
    #[msg("Not an admin")]
    NotAnAdmin,
    #[msg("Invalid role")]
    InvalidRole,
    #[msg("Invalid roles account")]
    InvalidRoles,
    #[msg("Permission denied")]
    PermissionDenied,
    #[msg("No such role")]
    NoSuchRole,
    #[msg("The role is disabled")]
    DisabledRole,
    // Oracle.
    #[msg("Oracle is not empty")]
    PricesAlreadySet,
    #[msg("Price of the given token already set")]
    PriceAlreadySet,
    #[msg("Invalid price feed account")]
    InvalidPriceFeedAccount,
    #[msg("Invalid price feed price")]
    InvalidPriceFeedPrice,
    #[msg("Price feed not updated")]
    PriceFeedNotUpdated,
    #[msg("Token config disabled")]
    TokenConfigDisabled,
    #[msg("Negative price is not allowed")]
    NegativePrice,
    #[msg("Price overflow")]
    PriceOverflow,
    #[msg("Price feed is not set for the given provider")]
    PriceFeedNotSet,
    #[msg("Not enough feeds")]
    NotEnoughFeeds,
    #[msg("Max price age exceeded")]
    MaxPriceAgeExceeded,
    #[msg("Invalid oracle timestamp range")]
    InvalidOracleTsTrange,
    #[msg("Max oracle timestamp range exceeded")]
    MaxOracleTimeStampRangeExceeded,
    #[msg("Oracle timestamps are smaller than required")]
    OracleTimestampsAreSmallerThanRequired,
    #[msg("Oracle timestamps are larger than requried")]
    OracleTimestampsAreLargerThanRequired,
    #[msg("Oracle not updated")]
    OracleNotUpdated,
    #[msg("Invalid oracle slot")]
    InvalidOracleSlot,
    // Market.
    #[msg("Computation error")]
    Computation,
    #[msg("Unsupported pool kind")]
    UnsupportedPoolKind,
    #[msg("Invalid collateral token")]
    InvalidCollateralToken,
    #[msg("Invalid market")]
    InvalidMarket,
    #[msg("Disabled market")]
    DisabledMarket,
    #[msg("Unknown swap out market")]
    UnknownSwapOutMarket,
    // Exchange Common.
    #[msg("Invalid swap path")]
    InvalidSwapPath,
    #[msg("Output amount too small")]
    OutputAmountTooSmall,
    #[msg("Amount is not zero but swap in token not provided")]
    AmountNonZeroMissingToken,
    #[msg("Missing token mint")]
    MissingTokenMint,
    #[msg("Missing oracle price")]
    MissingOracelPrice,
    // Withdrawal.
    #[msg("User mismach")]
    UserMismatch,
    #[msg("Empty withdrawal")]
    EmptyWithdrawal,
    #[msg("Invalid withdrawal to remove")]
    InvalidWithdrawalToRemove,
    #[msg("Unable to transfer out remaining withdrawal amount")]
    UnableToTransferOutRemainingWithdrawalAmount,
    // Deposit.
    #[msg("Empty deposit")]
    EmptyDeposit,
    #[msg("Missing deposit token account")]
    MissingDepositTokenAccount,
    #[msg("Invalid deposit to remove")]
    InvalidDepositToRemove,
    // Exchange.
    #[msg("Invalid position kind")]
    InvalidPositionKind,
    #[msg("Invalid position collateral token")]
    InvalidPositionCollateralToken,
    #[msg("Invalid position market")]
    InvalidPositionMarket,
    #[msg("Position account not provided")]
    PositionNotProvided,
    #[msg("Same secondary tokens not merged")]
    SameSecondaryTokensNotMerged,
    #[msg("Missing receivers")]
    MissingReceivers,
    // Position.
    #[msg("position is not initialized")]
    PositionNotInitalized,
    #[msg("position has been initialized")]
    PositionHasBeenInitialized,
    #[msg("position is not required")]
    PositionIsNotRequried,
    #[msg("position is not provided")]
    PositionIsNotProvided,
    #[msg("invalid position initialization params")]
    InvalidPositionInitailziationParams,
    #[msg("invalid position")]
    InvalidPosition,
    #[msg("invalid trade id")]
    InvalidTradeID,
    #[msg("invalid trade delta size")]
    InvalidTradeDeltaSize,
    #[msg("invalid borrowing factor")]
    InvalidBorrowingFactor,
    #[msg("invalid funding factors")]
    InvalidFundingFactors,
    // Order.
    #[msg("missing initialial token account for order")]
    MissingInitializeTokenAccountForOrder,
    #[msg("missing claimable time window")]
    MissingClaimableTimeWindow,
    #[msg("missing recent time window")]
    MissingRecentTimeWindow,
    #[msg("missing holding address")]
    MissingHoldingAddress,
    #[msg("missing sender")]
    MissingSender,
    #[msg("missing position")]
    MissingPosition,
    #[msg("missing claimable long collateral account for user")]
    MissingClaimableLongCollateralAccountForUser,
    #[msg("missing claimable short collateral account for user")]
    MissingClaimableShortCollateralAccountForUser,
    #[msg("missing claimable pnl token account for holding")]
    MissingClaimablePnlTokenAccountForHolding,
    #[msg("claimable collateral in output token for holding is not supported")]
    ClaimbleCollateralInOutputTokenForHolding,
    #[msg("no delegated authority is set")]
    NoDelegatedAuthorityIsSet,
    #[msg("invalid order to remove")]
    InvalidOrderToRemove,
    #[msg("ADL not enabled")]
    AdlNotEnabled,
    #[msg("ADL not required")]
    AdlNotRequired,
    #[msg("Invalid ADL")]
    InvalidAdl,
    #[msg("Invalid Trigger Price")]
    InvalidTriggerPrice,
    #[msg("Insufficient output amount or value")]
    InsufficientOutputAmount,
    // Token Config.
    #[msg("synthetic flag does not match")]
    InvalidSynthetic,
    #[msg("invalid token map")]
    InvalidTokenMap,
    // Invalid Provider Kind.
    #[msg("invalid provider kind index")]
    InvalidProviderKindIndex,
}

impl StoreError {
    #[inline]
    pub(crate) const fn invalid_position_kind(_kind: u8) -> Self {
        Self::InvalidPositionKind
    }
}

/// Data Store Resut.
pub type StoreResult<T> = std::result::Result<T, StoreError>;

#[error_code]
pub enum CoreError {
    /// Internal error.
    #[msg("internal error")]
    Internal,
    /// Permission denied.
    #[msg("permission denied")]
    PermissionDenied,
    /// Store Mismatched.
    #[msg("store mismatched")]
    StoreMismatched,
    /// Owner mismatched.
    #[msg("owner mismatched")]
    OwnerMismatched,
    /// Market mismatched.
    #[msg("market mismatched")]
    MarketMismatched,
    /// Position mismatched.
    #[msg("position mismatched")]
    PositionMismatched,
    /// Empty Deposit.
    #[msg("empty deposit")]
    EmptyDeposit,
    /// Empty Withdrawal.
    #[msg("emtpy withdrawal")]
    EmptyWithdrawal,
    /// Empty Order.
    #[msg("emtpy order")]
    EmptyOrder,
    /// Empty Shift.
    #[msg("emtpy shift")]
    EmptyShift,
    /// Invalid min output amount for limit swap.
    #[msg("invalid min output amount for limit swap order")]
    InvalidMinOutputAmount,
    /// Invalid trigger price.
    #[msg("invalid trigger price")]
    InvalidTriggerPrice,
    /// Invalid position.
    #[msg("invalid position")]
    InvalidPosition,
    /// Order kind is not allowed.
    #[msg("the order kind is not allowed by this instruction")]
    OrderKindNotAllowed,
    /// Token account is not provided.
    #[msg("required token account is not provided")]
    TokenAccountNotProvided,
    /// Token mint is not provided.
    #[msg("required token mint is not provided")]
    TokenMintNotProvided,
    /// Not enough token amounts.
    #[msg("not enough token amount")]
    NotEnoughTokenAmount,
    /// Not enough execution fee.
    #[msg("not enough execution fee")]
    NotEnoughExecutionFee,
    /// Invalid Swap Path length.
    #[msg("invalid swap path length")]
    InvalidSwapPathLength,
    /// Not enough swap markets in the path.
    #[msg("not enough swap markets in the path")]
    NotEnoughSwapMarkets,
    /// Invalid Swap Path.
    #[msg("invalid swap path")]
    InvalidSwapPath,
    /// Market token mint mismatched.
    #[msg("market token mint mismatched")]
    MarketTokenMintMismatched,
    /// Mint account not provided.
    #[msg("mint account not provided")]
    MintAccountNotProvided,
    /// Market token account mismatched.
    #[msg("market token account mismatched")]
    MarketTokenAccountMismatched,
    /// Token mint mismatched.
    #[msg("token mint mismatched")]
    TokenMintMismatched,
    /// Token account mismatched.
    #[msg("token account mismatched")]
    TokenAccountMismatched,
    /// Not an ATA for the given token.
    #[msg("not an ATA for the given token")]
    NotAnATA,
    /// Unknown Action State.
    #[msg("unknown action state")]
    UnknownActionState,
    /// Unknown Order Kind.
    #[msg("unknown order kind")]
    UnknownOrderKind,
    /// Unknown Order Side.
    #[msg("unknown order side")]
    UnknownOrderSide,
    /// Preconditions are not met.
    #[msg("preconditions are not met")]
    PreconditionsAreNotMet,
    /// Token amount exceeds limit.
    #[msg("token amount exceeds limit")]
    TokenAmountExceedsLimit,
    /// Not enough token feeds.
    #[msg("not enough token feeds")]
    NotEnoughTokenFeeds,
    /// Unknown or disabled token.
    #[msg("unknown or disabled token")]
    UnknownOrDisabledToken,
    /// Insufficient output amounts.
    #[msg("insufficient output amounts")]
    InsufficientOutputAmount,
    /// Position is not required.
    #[msg("position is not required")]
    PositionItNotRequired,
    /// Position is required.
    #[msg("position is required")]
    PositionIsRequired,
    /// Missing initial collateral token.
    #[msg("missing initial collateral token")]
    MissingInitialCollateralToken,
    /// Missing final output token.
    #[msg("missing final output token")]
    MissingFinalOutputToken,
    /// Missing pool tokens.
    #[msg("missing pool tokens")]
    MissingPoolTokens,
    /// Token amount overflow.
    #[msg("token amount overflow")]
    TokenAmountOverflow,
    /// Invalid Shift Markets
    #[msg("invalid shift markets")]
    InvalidShiftMarkets,
    /// GT State has been initialized.
    #[msg("GT State has been initialized")]
    GTStateHasBeenInitialized,
    /// Invalid GT config.
    #[msg("invalid GT config")]
    InvalidGTConfig,
    /// Invalid GT discount.
    #[msg("invalid GT discount")]
    InvalidGTDiscount,
}

impl CoreError {
    pub(crate) const fn unknown_action_state(_kind: u8) -> Self {
        Self::UnknownActionState
    }

    pub(crate) const fn unknown_order_kind(_kind: u8) -> Self {
        Self::UnknownOrderKind
    }

    pub(crate) const fn unknown_order_side(_kind: u8) -> Self {
        Self::UnknownOrderSide
    }
}
